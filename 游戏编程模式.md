## 解耦
### 解耦的好处
- 如果两块代码耦合那么学习的时候要两者都看，解耦只需看其一。降低了学习成本。
- 改变一块代码时不必更改另一块代码，改动的影响范围小。
### 它的代价
- 会产生多余的需要开发、维护的代码
- 过多的抽象和框架借口增加代码的理解难度



## 命令模式
将一个请求封装成一个对象，从而允许使用不同的请求、队列或日志将客户端参数化，同时支持请求操作的撤销与恢复  
**命令就是一个实例化的方法调用**  
**命令就是面向对象化的回调**
### 使用场景
#### 配置输入：通过一个间接调用层统一接受输入，再调用与输入类型相映射的可分配命令（角色和命令的解耦）
- 加入中间层可以让命令更加通用，只需要改变接收命令的角色对象引用即可
- AI代码提供命令以执行AI行为  
- 通过**命令流**实现生产者端和消费者端的解耦
#### 撤销和重做：为每一个命令添加回退接口，即保存命令执行之前的数据
- 多次撤销：维护一个命令列表，执行回退操作或前进则移动**当前命令指针**  
### 优缺点
- 降低了系统耦合度，且可以很快添加新命令
- 新增了很多命令类需要维护

*大部分命令都是**无状态**的纯行为代码，拥有多个相同的实例会浪费内存，因为这些实例是等价的*



## 享元模式
可以看作是工厂模式和单例模式的结合。主要通过将对象数据切分为两种类型来解决问题：**内部状态**（上下文无关状态）和**外部状态**。
#### 内部状态
- 可以被所有对象共享的数据组成的对象即为享元对象，一般只包含不可变数据
- 用唯一标识码判断这个对象是否在内存中；可以用HashMap存储这些对象
- 内部对象只被实例化一次
#### 外部状态
用于区分每个对象的数据
### 如何使用
定义一个单例的享元工厂：维护一个享元池（HashMap），提供一个查询享元对象的接口，有则返回没有则创建，保存在享元池，然后再返回。
### 优缺点
- 大大减少了对象的创建，优化了内存
- 提高了复杂度，需要对外部状态和内部状态进行区分和维护



## 观察者模式
在对象间定义一种一对多的依赖关系，以便当某对象的状态改变时，与它存在依赖关系的所有对象都能收到通知并自动进行更新。
### 使用场景
#### 成就系统
成就系统为观察者，所有成就事件为被观察者，被观察保存所有观察者的引用，在事件触发时显示回调观察者提供的接口。  
***目标对象的状态发送改变，所有观察者对象都将得到通知，通知方式为广播***
### 优缺点
- 观察者和被观察者是抽象耦合的（动态）
- 如果观察者数量太多，需要全部通知时间会过多
### 注意点
1. 观察者和被观察者之间不能有循环依赖
2. 同步触发可能会因为其中一个观察者导致系统卡死，可以采用异步方式



## 原型模式
实现一个原型接口，用于创建当前对象的克隆，在直接创建对象的代价比较大时采用在这种模式。
### 使用场景
对象的创建需要高代价的操作如数据库操作时，使用缓存的对象的克隆来代替对象的创建，当参数变化或数据库数据变更时才改变对象的原型。  
***代码需要支持对象的clone方法***
### 优缺点
- 性能提高且不需要调用类的构造函数
- 要对具体应用场景进行分析，有的类不支持存在多个相似的对象，可能会造成内存泄漏



## 单例模式
确保一个类只有一个实例，并为其提供一个全局访问入口
### 使用场景
- 一个全局唯一的对象，不会被频繁的创建和销毁，例如管理器
- 控制初始化时机，只有在调用时才会被初始化

#### 纯函数：不访问或不修改全局状态的函数

### 优缺点
- 内存中只有一个实例，减少了内存开销；避免了多个对象对统一资源的操作
- 全局变量会导致耦合，且对并发不友好；与单一原则冲突，不应该关心外部对类的实例化

### 实现方式
#### 懒汉式
延迟初始化，调用的时候判断是否存在实例，不存在则初始化静态实例，存在则直接返回引用；有线程问题。
#### 饿汉式
在单例类装载时就实例化，只提供获取实例的接口。



## 状态模式
通过划分状态来隔离对
### 有限状态机
- 得到一组状态，并且可以在这组状态之间进行切换
- 状态机同一时刻只能处于一种状态————使用状态机的原因：为了防止同时存在两个状态
- 状态机接收一组输入或事件
- 每一个状态有一组转换，每一个转换都关联着一个输入并指向另一个状态  

**总结：状态 - 输入 - 转换**  
**实现方法：枚举和分支**

### 使用场景
- 大量与对象状态相关的条件语句
- 对象行为随状态改变而改变

### 优点
1. 封装了转换规则
2. 状态对象可以复用
3. 状态可以很方便的扩展

### 缺点
1. 实现较为复杂，需要在恰当的系统使用，否则会造成浪费和混乱
2. 增加新状态需要修改代码，不能很好的支持开闭原则

### 并发状态机
使用**多个状态机**来并发表示可能同时出现的多种状态的组合，避免一个状态机包含过多的状态，减少代码的重复

### 层次自动机
状态通过继承的方式实现，子状态不处理的输入都有父状态去处理

### 自动下推机
通过维护一个状态栈来保存状态转换之前的状态，新状态到来时入站，结束时出战，返回到上一个状态


## 类型对象模式
根据不同的类型引用，区分不同类型的对象
并不需要根据继承区分类的类型